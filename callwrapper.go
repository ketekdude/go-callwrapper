package callwrapper

import (
	"context"
	"fmt"
	"time"

	"github.com/sony/gobreaker"
)

type Callwrapper struct {
	name           string
	config         CallwrapperConfig
	circuitBreaker BreakerInterface
	memcache       Cacher
}

type CallwrapperConfig struct {
	ServiceName              string
	FuncName                 string
	Timeout                  int           //in millisecond
	timeoutDuration          time.Duration //autogenerated, do not fill the value
	ErrWhitelist             []error
	mapErrWhitelist          map[error]bool
	CBOpenToHalfOpenDuration int                                                     //duratio from cb open to half  open in millisecond
	CBInterval               int                                                     //interval how long the success/fail request count last, use in millisecond
	CBOpenThreshold          int                                                     //how many fail request in consecutive to trigger CB, when set to 0, CB will never open
	OnCBStateChanges         func(cbName string, fromState, toState gobreaker.State) //what you want to do, if the CB state changes
	IsMemCache               bool
	CacheConfig              CacheConfig
}

type InterfaceCallwrapper interface {
	Call(ctx context.Context, reqKey string, f func(context.Context) (interface{}, error)) (interface{}, error)
	CheckBreaker()
}

func NewWrapper(cfg CallwrapperConfig) InterfaceCallwrapper {
	cfg.timeoutDuration = time.Duration(cfg.Timeout) * time.Millisecond
	//init whitelist error map
	if len(cfg.ErrWhitelist) > 0 {
		mapErr := make(map[error]bool)
		for _, v := range cfg.ErrWhitelist {
			mapErr[v] = true
		}
		cfg.mapErrWhitelist = mapErr
	}

	//default cb on state changes print to terminal
	if cfg.OnCBStateChanges == nil {
		cfg.OnCBStateChanges = func(name string, from, to gobreaker.State) {
			fmt.Printf("CircuitBreaker %s state changes from %s to %s\n", name, from, to)
		}
	}
	cb := newBreaker(cfg)

	cw := Callwrapper{
		name:           fmt.Sprintf("%s-%s", cfg.ServiceName, cfg.FuncName),
		config:         cfg,
		circuitBreaker: cb,
	}

	if cfg.IsMemCache {
		cache := newCache(cfg.CacheConfig.CacheSize, cfg.CacheConfig.CacheTTLSec)
		cw.memcache = cache
	}

	return &cw
}

func (c *Callwrapper) Call(ctx context.Context, reqKey string, fn func(ctx context.Context) (interface{}, error)) (interface{}, error) {
	//set timeout
	return c.circuitBreaker.Execute(func() (interface{}, error) {
		return c.callWithTimeout(ctx, reqKey, fn)
	})
}

func (c *Callwrapper) callWithTimeout(ctx context.Context, reqKey string, fn func(ctx context.Context) (interface{}, error)) (interface{}, error) {
	ctx, cancel := context.WithTimeout(ctx, c.config.timeoutDuration)
	defer cancel()
	start := time.Now()

	type response struct {
		result interface{}
		err    error
	}

	if c.config.IsMemCache {
		//get the data from memcache first
		if data, ok := c.memcache.Get(ctx, reqKey); ok {
			//directly return on memcache able to find the data
			return data, nil
		}
	}

	done := make(chan response, 1)

	go func() {
		resp, err := fn(ctx)
		done <- response{
			result: resp,
			err:    err,
		}
	}()
	select {
	case <-ctx.Done():
		err := fmt.Errorf("%s. TimeoutConfig: %d | Actual: %d", ctx.Err(), c.config.timeoutDuration.Milliseconds(), time.Since(start).Milliseconds())
		return nil, err
	case data := <-done:
		return data.result, data.err
	}
}

func (c *Callwrapper) CheckBreaker() {
	fmt.Println("Current CB State: ", c.circuitBreaker.State())
	fmt.Println("Current CB Failure Req: ", c.circuitBreaker.Counts().TotalFailures)
	fmt.Println("Current CB Success Req: ", c.circuitBreaker.Counts().TotalSuccesses)
}
